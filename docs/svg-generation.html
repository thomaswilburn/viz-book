<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Generating SVG from code</title>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono|Noto+Sans" rel="stylesheet">
  <link rel="stylesheet" href="static/style.css">
</head>
<body class="svg-generation chapter">
  <nav class="chapter-links top">
    <ul>
      <li class="previous"> <a href="svg-viewbox.html"> &laquo; Art direction with viewBox</a>
      <li> <a href="index.html">&bigstar;</a>
      <li class="next"> <a href=""> Applying CSS to an SVG graphic &raquo;</a>
    </ul>
  </nav>
  <main>
  <aside class="summary">
    Creating elements | Common shapes and coordinates | Paving the paths
  </aside>
  <h1>Generating SVG from code</h1>
<p>Although they can be written into HTML5 source code the same way as other elements, SVG elements are not HTML elements, and they don't act like it. In another chapter, we'll talk about the common pitfalls where this may catch you off guard. But for now, let's talk about how to generate SVG dynamically without wanting to chop off a finger.</p>
<h2><var>makeDOM</var> revisited</h2>
<p>In our chapter on <a href="js-domdata.html">working with DOM and data</a>, we wrote a function called <var>makeDOM</var> that generates HTML programmatically in a similar way to React's <var>createElement</var> function. When working with raw SVG, a similar function is a good thing to have, especially because there actually isn't an easy way to just hand the browser an SVG string for rendering the same way as <var>innerHTML</var>. Elements must be created and appended using DOM function calls.</p>
<p>To adapt our HTML generator to SVG, we'll need to make two changes. First, SVG elements have to be created with a "namespace" that identifies them as SVG, or they won't do anything when you insert them into the page. Second, if you want to set the contents of a <var>text</var> element, you have to use the <var>textContent</var> property instead of <var>innerText</var> or <var>innerHTML</var>.</p>
<code class="language-js"><pre><span class="line">const NS = "http://www.w3.org/2000/svg";
</span><span class="line">
</span><span class="line">var makeSVG = function(tagName, attrs, children) {
</span><span class="line">  var element = document.createElementNS(NS, tagName);
</span><span class="line">  if (attrs instanceof Array || typeof attrs == "string") {
</span><span class="line">    children = attrs;
</span><span class="line">    attrs = {};
</span><span class="line">  }
</span><span class="line">  if (attrs) for (var a in attrs) {
</span><span class="line">    element.setAttribute(a, attrs[a]);
</span><span class="line">  }
</span><span class="line">  if (children instanceof Array) {
</span><span class="line">    children.forEach(function(c) {
</span><span class="line">      element.appendChild(c);
</span><span class="line">    });
</span><span class="line">  } else if (typeof children == "string") {
</span><span class="line">    element.textContent = children;
</span><span class="line">  }
</span><span class="line">  return element;
</span><span class="line">};
</span></pre></code>
<p>To use this function, you have to at least give it a tag name. The other two arguments are optional: an object containing attributes you want to set, and either an array of child elements, or a string for the text content. So to generate some simple SVG shapes, we might write the following:</p>
<code class="language-js"><pre><span class="line">var m = makeSVG;
</span><span class="line">var group = m("g", [
</span><span class="line">  m("rect", { x: 10, y: 10, width: 20, height: 40 }),
</span><span class="line">  m("circle", { cx: 30, cy: 30, r: 40 })
</span><span class="line">]);
</span></pre></code>
<h2>We have to go deeper</h2>
<script>
//prep for examples
var data = {
  a: [22, 11, 22, 55, 66, 44, 77, 99, 77, 88, 88, 55],
  b: [55, 33, 44, 66, 22, 44, 77, 88, 99, 44, 77, 55]
};

var max = Math.max(Math.max(...data.a), Math.max(...data.b));

var h = Math.max(
  Math.max(...data.a),
  Math.max(...data.b)
);
// find the proportional width
var w = h / 480 * 640;

// create horizontal scaling function
var scaleX = v => v / (data.a.length - 1) * w;

var padding = 20;

const NS = "http://www.w3.org/2000/svg";

var m = function(tagName, attrs, children) {
  var element = document.createElementNS(NS, tagName);
  if (attrs instanceof Array || typeof attrs == "string") {
    children = attrs;
    attrs = {};
  }
  if (attrs) for (var a in attrs) {
    element.setAttribute(a, attrs[a]);
  }
  if (children instanceof Array) {
    children.forEach(function(c) {
      element.appendChild(c);
    });
  } else if (typeof children == "string") {
    element.textContent = children;
  }
  return element;
};
</script>
<style>
.svg-container {
  position: relative;
  outline: 1px dotted #EEE;
}

.svg-container::before {
  content: "";
  display: block;
  padding-bottom: 75%;
}

.svg-container svg {
  position: absolute;
  top: 0;
  left; 0;
  width: 100%;
  height: 100%;
}

.backdrop {
  fill: white;
}

.axis {
  stroke: black
}

.series {
  stroke-width: 4px;
  stroke: black;
  fill: none;
}

.series.a {
  stroke: salmon;
}

.series.b {
  stroke: rebeccapurple;
}
</style>
<p>Now that we have an easy way to generate SVG elements, let's create a graphic with it: a simple line chart. Adding scale lines and labels will be left as an exercise for the reader&mdash;this is just two data series in a rectangle for demonstration purposes.</p>
<p>Most of the time when I see people build a chart in an SVG, probably using something like D3, they set the width and the height of the element (but not the view box), and then figure out the amount of padding that they want on each side of the actual graph. By subtracting the padding from the SVG's dimensions, they get the width and height of the drawing area. All coordinates are scaled to that area, and then offset by the padding, so that the line is placed in the right location.</p>
<p>However, there's an easier way to do this, rather than mucking around with all the offset math and working within an arbitrary graph area using pixels for measurement. We can take advantage of an interesting property of SVG tags, which is that they can be nested within each other. The inner image can have its own x/y position, its own width and height, and its own view box (meaning, <a href="https://www.sarasoueidan.com/blog/mimic-relative-positioning-in-svg/">its own internal coordinate space</a>). Instead of working with pixels, we can actually draw things just by projecting the data values directly into the graphic.</p>
<p>Let's take a look at how to make this SVG inception happen. We'll start with our outer SVG, which is sized to a standard 640x480 canvas with a matching view box. These coordinates are arbitrary but chosen because within the outer image, we <em>do</em> want to work in pixels&mdash;it's easier to set visual padding that way.</p>
<code class="language-html"><pre><span class="line">&lt;svg class="graph-container" width="640" height="480" viewBox="0 0 640 480"&gt;&lt;/svg&gt;
</span></pre></code>
<p>Inside, we can add some "chart junk" to establish the space: a group containing a background rectangle with some color, and two lines to show the left and bottom axes. We'll put 20 pixels of padding on either side.</p>
<code class="language-js"><pre><span class="line">// shorten the makeSVG function for readability
</span><span class="line">var m = makeSVG;
</span><span class="line">
</span><span class="line">var padding = 20;
</span><span class="line">
</span><span class="line">var backdrop = m("g", [
</span><span class="line">  m("rect", {
</span><span class="line">    x: padding, y: padding,
</span><span class="line">    width: 640 - padding * 2,
</span><span class="line">    height: 480 - padding * 2,
</span><span class="line">    fill: "#EEE"
</span><span class="line">  }),
</span><span class="line">  m("line", {
</span><span class="line">    x1: padding, y1: padding,
</span><span class="line">    x2: padding, y2: 480 - padding,
</span><span class="line">    stroke: "#CCC"
</span><span class="line">  }),
</span><span class="line">  m("line", {
</span><span class="line">    x1: padding, y1: 480 - padding,
</span><span class="line">    x2: 640 - padding, y2: 480 - padding,
</span><span class="line">    stroke: "#CCC"
</span><span class="line">  })
</span><span class="line">]);
</span><span class="line">
</span><span class="line">var container = document.querySelector(".graph-container");
</span><span class="line">container.appendChild(backdrop);
</span></pre></code>
<div class="svg-container">
<svg class="graph-backdrop" width="640" height="640" viewBox="0 0 640 480"></svg>
</div>
<script>
(function() {
var backdrop = m("g", [
  m("rect", {
    x: padding, y: padding,
    width: 640 - padding * 2,
    height: 480 - padding * 2,
    fill: "#EEE"
  }),
  m("line", {
    x1: padding, y1: padding,
    x2: padding, y2: 480 - padding,
    stroke: "#CCC"
  }),
  m("line", {
    x1: padding, y1: 480 - padding,
    x2: 640 - padding, y2: 480 - padding,
    stroke: "#CCC"
  })
]);

var container = document.querySelector(".graph-backdrop");
container.appendChild(backdrop);
})();
</script>
<p>Now we'll define our inner SVG. From the outside, it'll be the same size as the backing rectangle, but from the inside, its coordinate system's height will be scaled to match our data, which goes from zero to 100. From the height, we'll figure the width from the chart's aspect ratio, so that our internal space doesn't get distorted (although we could always use the "preserveAspectRatio" attribute to center it, it wouldn't fill the space that way, and our goal is to be more visually precise).</p>
<code class="language-js"><pre><span class="line">// 12 "months" of data
</span><span class="line">var data = {
</span><span class="line">  a: [22, 11, 22, 55, 66, 44, 77, 99, 77, 88, 88, 55],
</span><span class="line">  b: [55, 33, 44, 66, 22, 44, 77, 88, 99, 44, 77, 55]
</span><span class="line">};
</span><span class="line">
</span><span class="line">var h = Math.max(
</span><span class="line">  Math.max(...data.a),
</span><span class="line">  Math.max(...data.b)
</span><span class="line">);
</span><span class="line">// find the proportional width
</span><span class="line">var w = h / 480 * 640;
</span><span class="line">
</span><span class="line">// create horizontal scaling function
</span><span class="line">var scaleX = v =&gt; v / (data.length - 1) * w;
</span><span class="line">
</span><span class="line">// place our SVG on top of the backdrop
</span><span class="line">var bounds = backdrop.getBBox();
</span><span class="line">
</span><span class="line">var inner = m("svg", {
</span><span class="line">  x: bounds.x, y: bounds.y,
</span><span class="line">  width: bounds.width, height: bounds.height,
</span><span class="line">  viewBox: `0 0 ${w} ${h}`,
</span><span class="line">  preserveAspectRatio: "none"
</span><span class="line">});
</span><span class="line">
</span><span class="line">svg.appendChild(inner);
</span></pre></code>
<p>Inside of this inner SVG, our coordinate space is much simpler to deal with. The Y coordinates for a data point are just that data point's value (albeit inverted by subtracting it from the height). The X coordinates go through our scaling function. And we can create those as points in a polyline by mapping the data through a very simple function:</p>
<code class="language-js"><pre><span class="line">for (var key in data) {
</span><span class="line">  svg.appendChild(m("polyline", {
</span><span class="line">    // polyline points look like "x,y x,y x,y"
</span><span class="line">    points: data[key].map((v, i) =&gt; `${scaleX(i)},${h - v}`).join(" "),
</span><span class="line">    fill: "none",
</span><span class="line">    stroke: "black"
</span><span class="line">  }));
</span><span class="line">}
</span></pre></code>
<div class="svg-container">
  <svg class="graph-traditional" width="640" height="480" viewBox="0 0 640 480">
</div>
<script>
(function() {
var svg = document.querySelector("svg.graph-traditional");

var backdrop = m("g", [
  m("rect", {
    x: padding, y: padding,
    width: 640 - padding * 2,
    height: 480 - padding * 2,
    fill: "#EEE"
  }),
  m("line", {
    x1: padding, y1: padding,
    x2: padding, y2: 480 - padding,
    stroke: "#DDD"
  }),
  m("line", {
    x1: padding, y1: 480 - padding,
    x2: 640 - padding, y2: 480 - padding
  })
]);

svg.appendChild(backdrop);

// place our SVG on top of the backdrop
var bounds = backdrop.getBBox();

var inner = m("svg", {
  x: bounds.x, y: bounds.y,
  width: bounds.width, height: bounds.height,
  viewBox: `0 0 ${w} ${h}`,
  preserveAspectRatio: "none"
});

svg.appendChild(inner);

for (var key in data) {
  inner.appendChild(m("polyline", {
    points: data[key].map((v, i) => `${scaleX(i)},${h - v}`).join(" "),
    fill: "none",
    stroke: "black"
    // class: "series " + key
    //"vector-effect": "non-scaling-stroke"
  }));
}

})();
</script>
<p>All in all, this is a pretty easy way to make a chart. Using an SVG view box to map our data domain to visual coordinates works pretty well. But what if we make it even easier? What if, in addition to mapping our data values directly to y-axis position, we also mapped the data's index and length to the x-axis? In that case, we don't need to scale at all: the SVG renderer will do it for us.</p>
<p>Unfortunately, it's not possible to invert an SVG viewbox so that the coordinates go up from the bottom, because negative width/height values are disallowed. But we can set a viewbox that starts negative and ends at zero, and just flip our values by adding a negative sign, and that'll accomplish the same goal. Here's how we'd write that graph:</p>
<code class="language-js"><pre><span class="line">var inner = m("svg", {
</span><span class="line">  x: bounds.x, y: bounds.y,
</span><span class="line">  width: bounds.width, height: bounds.height,
</span><span class="line">  // start at -height, and finish at 0
</span><span class="line">  viewBox: `0 ${-h} ${data.a.length - 1} ${h}`,
</span><span class="line">  preserveAspectRatio: "none"
</span><span class="line">});
</span><span class="line">
</span><span class="line">for (var key in data) {
</span><span class="line">  inner.appendChild(m("polyline", {
</span><span class="line">    // no scaling needed, only inverted Y
</span><span class="line">    points: data[key].map((v, i) =&gt; `${i},${-v}`).join(" "),
</span><span class="line">    fill: "none",
</span><span class="line">    stroke: "black"
</span><span class="line">  }));
</span><span class="line">}
</span><span class="line">
</span><span class="line">svg.appendChild(inner);
</span></pre></code>
<div class="svg-container">
  <svg width="640" height="480" viewBox="0 0 640 480" class="graph-distorted" preserveAspectRatio="none"></svg>
</div>
<script>
var svg = document.querySelector("svg.graph-distorted");

var backdrop = m("g", [
  m("rect", {
    x: padding, y: padding,
    width: 640 - padding * 2,
    height: 480 - padding * 2,
    fill: "#EEE"
  }),
  m("line", {
    x1: padding, y1: padding,
    x2: padding, y2: 480 - padding,
    stroke: "#DDD"
  }),
  m("line", {
    x1: padding, y1: 480 - padding,
    x2: 640 - padding, y2: 480 - padding
  })
]);

svg.appendChild(backdrop);

// place our SVG on top of the backdrop
var bounds = backdrop.getBBox();

var inner = m("svg", {
  x: bounds.x, y: bounds.y,
  width: bounds.width, height: bounds.height,
  viewBox: `0 ${-h} ${data.a.length - 1} ${h}`,
  preserveAspectRatio: "none"
});

svg.appendChild(inner);

for (var key in data) {
  inner.appendChild(m("polyline", {
    points: data[key].map((v, i) => `${i},${0 - v}`).join(" "),
    fill: "none",
    stroke: "black"
    // class: "series " + key
    //"vector-effect": "non-scaling-stroke"
  }));
}

</script>
<p>Oops: because our internal coordinate system is now very small and also very distorted, our lines (and any other shape we put inside) are too big and skewed. Rather than scale down our stroke to something tiny and hope that the distortion isn't visible, we can take advantage of a new SVG property called "vector-effect" to tell the stroke that it should be drawn in screen pixels, not in SVG pixels.</p>
<code class="language-js"><pre><span class="line">for (var key in data) {
</span><span class="line">  inner.appendChild(m("polyline", {
</span><span class="line">    points: data[key].map((v, i) =&gt; `${i},${0 - v}`).join(" "),
</span><span class="line">    fill: "none",
</span><span class="line">    stroke: "black",
</span><span class="line">    // draw strokes via screen coordinates, not SVG coordinates
</span><span class="line">    "vector-effect": "non-scaling-stroke"
</span><span class="line">  }));
</span><span class="line">}
</span></pre></code>
<div class="svg-container">
  <svg width="640" height="480" viewBox="0 0 640 480" class="graph-vector-effect" preserveAspectRatio="none"></svg>
</div>
<script>
var svg = document.querySelector("svg.graph-vector-effect");

var backdrop = m("g", [
  m("rect", {
    x: padding, y: padding,
    width: 640 - padding * 2,
    height: 480 - padding * 2,
    fill: "#EEE"
  }),
  m("line", {
    x1: padding, y1: padding,
    x2: padding, y2: 480 - padding,
    stroke: "#DDD"
  }),
  m("line", {
    x1: padding, y1: 480 - padding,
    x2: 640 - padding, y2: 480 - padding
  })
]);

svg.appendChild(backdrop);

// place our SVG on top of the backdrop
var bounds = backdrop.getBBox();

var inner = m("svg", {
  x: bounds.x, y: bounds.y,
  width: bounds.width, height: bounds.height,
  viewBox: `0 ${-h} ${data.a.length - 1} ${h}`,
  preserveAspectRatio: "none"
});

svg.appendChild(inner);

for (var key in data) {
  inner.appendChild(m("polyline", {
    points: data[key].map((v, i) => `${i},${0 - v}`).join(" "),
    fill: "none",
    stroke: "black",
    "vector-effect": "non-scaling-stroke"
  }));
}

</script>
<p>Vector effects are not available in old Internet Explorer versions or Edge, but they're part of the SVG2 spec and are already in all other modern browsers. Of course, you can also set up your graph as a non-data view box, and just write a couple of scaling functions too. But what would be the fun in that?</p>
  </main>
  <nav class="chapter-links bottom">
    <ul>
      <li class="previous"> <a href="svg-viewbox.html"> &laquo; Art direction with viewBox</a>
      <li> <a href="index.html">&bigstar;</a>
      <li class="next"> <a href=""> Applying CSS to an SVG graphic &raquo;</a>
    </ul>
  </nav>
</body>
</html>
