@metadata...
title:Deconstructing jQuery
type:chapter
...metadata

I love to eat, so I love watching cooking shows. One staple of these shows, of course, is the "deconstructed" meal: take the ingredients for something commonplace, like a hamburger, and then prepare a meal where those ingredients are reassembled to create a new form for the old dish. It's a little silly and pretentious, but it's also a cool way to think about how flavor and presentation come together to create a taste.

On the web, a classic flavor is jQuery: the ur-library that tamed a wildly inconsistent range of browsers, and made it possible to build interactive pages without wanting to stick your head in the microwave. But browsers kept improving, and some of jQuery's features became antipatterns. It's a perfect example of this book's thesis: these days, you probably don't need everything that the library does:

* AJAX - replaced by <var>fetch</var>
* Deferred - replaced by built-in Promise support
* Effects - replaced by CSS animations and transitions
* Offset and dimensions - replaced by <var>getBoundingClientRect()</var>

That doesn't mean that jQuery is worthless&mdash;far from it! The fundamental pattern of selection and iteration is a good one, and we still need to be able to perform DOM manipulation to add and remove classes, or to listen for events. But let's see if we can make a "deconstructed jQuery:" similar API flavor, but as a set of micro-modules that we can mix and match as demanded, so that we don't have to load a big library full of stuff we don't need just for basic tasks.

@sidebar...

This practice of breaking a big library into a set of smaller libraries became much more common when JavaScript developers started using npm to distribute front-end code. npm, a package manager normally used for Node scripts, was already designed to let developers build big applications from small packages. Tools like Browserify let front-end coders re-use those same modules, and distribute their own libraries using the same insfrastructure.

However, front-end developers should be aware that depending on how many small modules you bundle together, there may be a performance cost. Nolan Lawson has written about "<a href="https://nolanlawson.com/2016/08/15/the-cost-of-small-modules/">the cost of small modules</a>" extensively, showing that the process of organizing and loading all those tiny scripts can cause a substantial start-up penalty for your application.

That said, for this case, it's not a big deal. Nolan's research was aimed at big applications loading hundreds, or even thousands, of individual modules. Whereas for most news graphics, you'll probably be loading far fewer. It's mostly important to keep the cost in mind, and be aware of how different module toolkits (like Rollup or Closure) can address the problem.

...sidebar

To replace jQuery's core functionality, we need to handle a few basic tasks. We need to be able to select multiple elements and perform tasks on all of them. We need to be able to walk back up the DOM tree, given a child element and a selector. And we need to be able to add delegated event listeners (meaning that they're attached at higher level, instead of on the elements where the event is triggered), which are crucial for interactive apps that may replace big chunks of the page with new content. Luckily, each of these tasks combines with the next in a neat, composable way.

@subhead Making selections

Let's start by making some selections. After jQuery's popularity became obvious, browsers added a similar <var>querySelectorAll</var> function for searching the document. Unfortunately, this function wasn't as useful as a regular jQuery search was, because the object wasn't an array that you could loop through. Instead, it was a NodeList, an array-<em>like</em> object that had numbered items and a length, but lacked important methods like <var>forEach</var> or <var>map</var>.

Luckily, it's pretty easy to convert a NodeList into a JavaScript array. In newer browsers, you can use <var>Array.from()</var>, but for broader compatibility we can "borrow" the Array prototype's <var>slice</var> method to make a copy, which even works on array-likes. Here's the code for a jQuery-like query that can start at the document or at a chosen child node:

@codeblock...
var $ = (selector, d = document) => Array.prototype.slice.call(d.querySelectorAll(selector));
...codeblock

This function returns an array containing all the selected nodes. If you call it with a different node as the second argument, it'll use that as the root of the search, instead of looking through the entire document. Pretty handy!

In jQuery, once you made a selection, any methods you called on the object would be applied to everything in it. Our function isn't quite as powerful, but since it returns an array, we can use the <var>forEach()</var> method to iterate through it with an arrow function. For example, to change the style of every link on the page, we might do this:

@codeblock...
$("a").forEach(a => a.style.color = "red");
...codeblock

Let's try a more realistic example. jQuery make it easy to add or remove classes from a group of elements. Browser developers knew that manually manipulating the <var>className</var> property of an element was too cumbersome, so they added the <var>classList</var> property, which supports operations for <var>add</var>, <var>remove</var>, <var>contains</var>, and <var>toggle</var> operations. So, for example, to update a few classes on the page:

@codeblock...
//jQuery version
$("tab.selected").removeClass("hidden");
$("tab.disabled").addClass("hidden");

//Our module
$("tab.selected").forEach(el => el.classList.remove("hidden"));
$("tab.disabled").forEach(el => el.classList.add("hidden"));
...codeblock

It's a little more verbose, sure. But I would argue that the meaning is more clear, and that it's easier to think about what you can "do" to our version of the object, since the answer is "anything I can do to an array."

Of course, sometimes, you just want one thing, and then iterating over an array is much more cumbersome. So let's add a method to our <var>$</var> function that grabs just one item from the page:

@codeblock...
$.one = (s, d = document) => d.querySelector(s);

//changing just one item is easy
$.one("tab.active").classList.toggle("active");
...codeblock

@subhead Walking up the tree

@subhead Delegating events