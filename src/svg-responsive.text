@metadata...
title:Responsive graphics with SVG
type:chapter
summary:Inline and external embeds | Applied media queries | Views with a room
...metadata

We're naturally interested in SVG because it gives us an easy way to draw live vectors in the browser&mdash;shapes that can be manipulated, listen for events, and announce themselves in a screen reader. But SVG is also interesting because its presentation can be manipulated using CSS, including media queries and complex selectors. This opens up new possibilities, both for data visualization and art direction.

To really understand how SVG interacts with CSS, we need to talk about how it gets included in the page. Thus far, we've been generating or working with inline SVG, which is content directly placed in an HTML page. The HTML5 parser guarantees that inline <var>&lt;svg&gt;</var> tags simply work, although we do need to use the correct namespace when <a href="svg-generation.html">generating new elements dynamically</a>. So this just works:

@codeblock(html)...
<div>
  <svg width="100" height="100">
    <rect x="10" y="10" height="40" width="40"></rect>
  </svg>
</div>
...codeblock

You can also include a separate SVG file in a page, same as a JPG or PNG file, using an <var>&lt;img&gt;</var> tag. 

@codeblock(html)...
<img src="filename.svg">
...codeblock

However, when included through an image tag, the SVG is "opaque" to the rest of the page: it can't be inspected, you can't access its internal elements from scripts or styles, and it's not allowed to load external resources or run scripts. This makes them largely inert compared to inline elements, but they can still include internal CSS, and they can expose some manipulation capability through the URL used to load them.

@subhead The media is the message

When using media queries with SVG, the difference becomes clear. For example, here's the same SVG loaded twice: once through an inline tag, and once as an external resource. In both cases, the SVG contains a <var>&lt;style&gt;</var> tag that sets the fill of the rectangle with a 400px breakpoint:

@codeblock(html)...
<svg width="100" height="100 viewBox="0 0 100">
  <style>
rect { fill: blue }
@media (min-width: 400px) {
  rect { fill: green }
}
  </style>
  <rect x="20" y="20" width="60" height="60"></rect>
</svg>
...codeblock

If you're on a desktop machine, try resizing your window to see when the square changes color.

@html...
<svg width="100" height="100 viewBox="0 0 100" style="display: block">
  <style>
rect { fill: blue }
@media (min-width: 400px) {
  rect { fill: green }
}
  </style>
  <rect x="20" y="20" width="60" height="60"></rect>
</svg>

<img src="static/media-query.svg" style="width: 80%; padding: 0 40px; display: block">
...html

You should see the second square, the image tag, change color slightly before the first. This is because for the image, the "viewport" that determines the effect of the media query isn't the browser window, it's the image tag itself. The behavior is similar to that of an iframe, in that the "window" for the enclosed contents is basically just the tag.

This ability to adjust styles based on the size of the image element, and not the size of the browser window, makes external SVG ideal for loading resources like icons or logos. When the element is styled smaller, you can use the stylesheet to hide details for readability. When it's shown as a larger part of the page, the same file can add detail, incorporate extra text, or even swap out parts of the image entirely.

@subhead Powering small multiples with CSS



@subhead The limits of SVG media queries



@subhead Art directing with <var>srcset</var>

